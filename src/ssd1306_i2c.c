/*
 * Copyright (c) 2017, Stanislav Lakhtin.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. No personal names or organizations' names associated with the
 *    Atomthreads project may be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <ssd1306_i2c.h>


#include <string.h>
#include <stdlib.h>
#include <fonts.h>

#define _IF_SB(i2c) ((I2C_SR1(i2c) & I2C_SR1_SB) == 0)
#define _IF_BTF(i2c) ((I2C_SR1(i2c) & I2C_SR1_BTF) == 0)
#define _IF_ADDR(i2c) ((I2C_SR1(i2c) & I2C_SR1_ADDR) == 0)
#define _IF_TxE(i2c) (I2C_SR1(i2c) & I2C_SR1_TxE) == 0

#define DATAONLY (uint8_t)0b01000000
#define COMMAND  (uint8_t)0b00000000


uint32_t I2C_OLED = I2C2;
uint8_t OLED_ADDRESS = DEFAULT_7bit_OLED_SLAVE_ADDRESS;


/* Private SSD1306 structure */
typedef struct {
	uint16_t CurrentX;
	uint16_t CurrentY;
	uint8_t Inverted;
	uint8_t Initialized;
} SSD1306_t;

/* Private variable */
static SSD1306_t SSD1306;

// just noise to check a screen
// todo make logo or something else

static uint8_t screenRAM[SSD1306_WIDTH * SSD1306_HEIGHT / 8]; /* = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xc0,0x30
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x3c,0x0c
    ,0x00,0x00,0x00,0x00,0x00,0x03,0xf0,0x03,0xe7,0xf6,0x01,0xf0,0x00,0x00,0x07,0x03
    ,0x00,0x08,0x00,0x00,0x00,0x3c,0x10,0x3c,0x78,0x01,0x80,0x0f,0x00,0x00,0x00,0xe0
    ,0x00,0x08,0x00,0x00,0x03,0xc0,0x21,0xc7,0x80,0x00,0x40,0x00,0xe0,0x00,0x00,0x18
    ,0x00,0x08,0x00,0x00,0x3c,0x00,0x46,0x38,0x00,0x00,0x20,0x00,0x18,0x00,0x00,0x06

    ,0x00,0x08,0x00,0x00,0xc7,0xfc,0x48,0x40,0x00,0x00,0x20,0x00,0x04,0x00,0x00,0x01
    ,0x00,0x08,0x00,0x03,0x38,0x03,0x90,0x80,0x00,0x01,0xff,0xe0,0x02,0x00,0x00,0x00
    ,0x00,0x08,0x00,0x05,0xc0,0x00,0x90,0x80,0x00,0x0e,0x10,0x1c,0x01,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x1e,0x00,0x00,0x90,0x80,0x00,0x18,0x10,0x02,0x00,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x28,0x00,0x00,0x88,0x40,0x00,0x18,0x30,0x01,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x30,0x00,0x00,0x48,0x20,0x00,0x0c,0x20,0x03,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x44,0x20,0x00,0x00,0x20,0x1c,0x00,0x40,0x00,0x03
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x24,0x10,0x00,0x00,0x41,0xe0,0x00,0x40,0x00,0x0e

    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x32,0x0e,0x00,0x00,0xfe,0x00,0x01,0xc0,0x00,0x30
    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x09,0x81,0xff,0xff,0x80,0x00,0x0e,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x90,0x00,0x00,0x04,0x40,0x00,0x06,0x00,0x00,0xf0,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x8c,0x00,0x00,0x03,0x30,0x00,0x08,0x00,0x1f,0x00,0x00,0x78,0x01
    ,0x00,0x00,0x00,0x83,0x00,0x00,0x00,0xcc,0x00,0x30,0x07,0xe0,0x00,0x03,0x80,0x1e
    ,0x00,0x00,0x00,0x80,0xc0,0x00,0x00,0x33,0xff,0xff,0xf8,0x00,0x00,0x7c,0x01,0xe0
    ,0x00,0x21,0x00,0x80,0x38,0x00,0x00,0x0e,0x03,0x00,0x00,0x00,0x3f,0x80,0x3e,0x00
    ,0x00,0x7f,0x80,0x80,0x07,0x00,0x00,0x01,0xec,0x00,0x00,0x1f,0xc0,0x7f,0xc0,0x00

    ,0x00,0x00,0x00,0x40,0x00,0xfc,0x00,0x00,0x3f,0xf0,0x7f,0xef,0xff,0x80,0x00,0x00
    ,0x00,0x33,0x00,0x20,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x1e,0x00,0x06,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x02,0x00,0x01,0xf0,0x01,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xc0,0x30
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x3c,0x0c
    ,0x00,0x00,0x00,0x00,0x00,0x03,0xf0,0x03,0xe7,0xf6,0x01,0xf0,0x00,0x00,0x07,0x03
    ,0x00,0x08,0x00,0x00,0x00,0x3c,0x10,0x3c,0x78,0x01,0x80,0x0f,0x00,0x00,0x00,0xe0
    ,0x00,0x08,0x00,0x00,0x03,0xc0,0x21,0xc7,0x80,0x00,0x40,0x00,0xe0,0x00,0x00,0x18
    ,0x00,0x08,0x00,0x00,0x3c,0x00,0x46,0x38,0x00,0x00,0x20,0x00,0x18,0x00,0x00,0x06

    ,0x00,0x08,0x00,0x00,0xc7,0xfc,0x48,0x40,0x00,0x00,0x20,0x00,0x04,0x00,0x00,0x01
    ,0x00,0x08,0x00,0x03,0x38,0x03,0x90,0x80,0x00,0x01,0xff,0xe0,0x02,0x00,0x00,0x00
    ,0x00,0x08,0x00,0x05,0xc0,0x00,0x90,0x80,0x00,0x0e,0x10,0x1c,0x01,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x1e,0x00,0x00,0x90,0x80,0x00,0x18,0x10,0x02,0x00,0x80,0x00,0x00
    ,0x00,0x08,0x00,0x28,0x00,0x00,0x88,0x40,0x00,0x18,0x30,0x01,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x30,0x00,0x00,0x48,0x20,0x00,0x0c,0x20,0x03,0x00,0x40,0x00,0x00
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x44,0x20,0x00,0x00,0x20,0x1c,0x00,0x40,0x00,0x03
    ,0x00,0x08,0x00,0x60,0x00,0x00,0x24,0x10,0x00,0x00,0x41,0xe0,0x00,0x40,0x00,0x0e

    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x32,0x0e,0x00,0x00,0xfe,0x00,0x01,0xc0,0x00,0x30
    ,0x00,0x00,0x00,0xa0,0x00,0x00,0x09,0x81,0xff,0xff,0x80,0x00,0x0e,0x00,0x01,0xc0
    ,0x00,0x00,0x00,0x90,0x00,0x00,0x04,0x40,0x00,0x06,0x00,0x00,0xf0,0x00,0x06,0x00
    ,0x00,0x00,0x00,0x8c,0x00,0x00,0x03,0x30,0x00,0x08,0x00,0x1f,0x00,0x00,0x78,0x01
    ,0x00,0x00,0x00,0x83,0x00,0x00,0x00,0xcc,0x00,0x30,0x07,0xe0,0x00,0x03,0x80,0x1e
    ,0x00,0x00,0x00,0x80,0xc0,0x00,0x00,0x33,0xff,0xff,0xf8,0x00,0x00,0x7c,0x01,0xe0
    ,0x00,0x21,0x00,0x80,0x38,0x00,0x00,0x0e,0x03,0x00,0x00,0x00,0x3f,0x80,0x3e,0x00
    ,0x00,0x7f,0x80,0x80,0x07,0x00,0x00,0x01,0xec,0x00,0x00,0x1f,0xc0,0x7f,0xc0,0x00

    ,0x00,0x00,0x00,0x40,0x00,0xfc,0x00,0x00,0x3f,0xf0,0x7f,0xef,0xff,0x80,0x00,0x00
    ,0x00,0x33,0x00,0x20,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x1e,0x00,0x06,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x02,0x00,0x01,0xf0,0x01,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
*/
uint32_t reg32 __attribute__((unused));

void ssd1306_start(void) {
  i2c_send_start(I2C_OLED);
  while (_IF_SB(I2C_OLED));
  i2c_send_7bit_address(I2C_OLED, OLED_ADDRESS, I2C_WRITE);
  while (_IF_ADDR(I2C_OLED));
  /* Cleaning ADDR condition sequence. */
  reg32 = I2C_SR2(I2C_OLED);
}

void ssd1306_stop(void) {
  i2c_send_stop(I2C_OLED);
  while (_IF_BTF(I2C_OLED));
}

void ssd1306_send(uint8_t spec) {
  i2c_send_data(I2C_OLED, spec);
  while (_IF_TxE(I2C_OLED));
}

void ssd1306_send_data(uint8_t spec, uint8_t data) {
  ssd1306_start();
  ssd1306_send(spec);
  ssd1306_send(data);
  ssd1306_stop();
}


void ssd1306_send_command(uint8_t cmd) {
  ssd1306_start();
  ssd1306_send(0x00);
  ssd1306_send(cmd);
  ssd1306_stop();
}

void ssd1306_init(uint32_t i2c, uint8_t address) {
  I2C_OLED = i2c;
  OLED_ADDRESS = address;
  
  
  /* Init LCD */
  ssd1306_send_command(0xAE); //display off
  ssd1306_send_command(0x20); //Set Memory Addressing Mode   
  ssd1306_send_command(0x10); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
  ssd1306_send_command(0xB0); //Set Page Start Address for Page Addressing Mode,0-7
  ssd1306_send_command(0xC8); //Set COM Output Scan Direction
  ssd1306_send_command(0x00); //---set low column address
  ssd1306_send_command(0x10); //---set high column address
  ssd1306_send_command(0x40); //--set start line address
  ssd1306_send_command(0x81); //--set contrast control register
  ssd1306_send_command(0xFF);
  ssd1306_send_command(0xA1); //--set segment re-map 0 to 127
  ssd1306_send_command(0xA6); //--set normal display
  ssd1306_send_command(0xA8); //--set multiplex ratio(1 to 64)
  ssd1306_send_command(0x3F); //
  ssd1306_send_command(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
  ssd1306_send_command(0xD3); //-set display offset
  ssd1306_send_command(0x00); //-not offset
  ssd1306_send_command(0xD5); //--set display clock divide ratio/oscillator frequency
  ssd1306_send_command(0xF0); //--set divide ratio
  ssd1306_send_command(0xD9); //--set pre-charge period
  ssd1306_send_command(0x22); //
  ssd1306_send_command(0xDA); //--set com pins hardware configuration
  ssd1306_send_command(0x12);
  ssd1306_send_command(0xDB); //--set vcomh
  ssd1306_send_command(0x20); //0x20,0.77xVcc
  ssd1306_send_command(0x8D); //--set DC-DC enable
  ssd1306_send_command(0x14); //
  ssd1306_send_command(0xAF); //--turn on SSD1306 panel
 
  SSD1306.CurrentX = 0;
  SSD1306.CurrentY = 0;
  ssd1306_refresh();

  // Reset adressing mode to Horizontal
  ssd1306_send_command(0x20); //Set Memory Addressing Mode   
  ssd1306_send_command(0x00); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid

  // Set Column Address Scope
  ssd1306_send_command(0x21);
  ssd1306_send_command(0);
  ssd1306_send_command(SSD1306_WIDTH-1);

  // Set Page Address Scope
  ssd1306_send_command(0x22);
  ssd1306_send_command(0);
  ssd1306_send_command(SSD1306_HEIGHT/8-1);
  
}

void ssd1306_clear(void) {
  memset(screenRAM, 0x00, sizeof(screenRAM)); //TODO check if "memset" is safe in our env
}

/**
 * Send (and display if OLED is ON) RAM buffer to device
 */
void ssd1306_refresh(void) {
  // ssd1306_setMemoryAddressingMode(Horizontal);
  // ssd1306_setColumnAddressScope(0,SSD1306_WIDTH-1);
  // ssd1306_setPageAddressScope(0,SSD1306_HEIGHT/8-1);
  ssd1306_start();
  ssd1306_send(DATAONLY);
  for (uint16_t i=0; i < sizeof(screenRAM); i++) {
    i2c_send_data(I2C_OLED, screenRAM[i]); //todo make it with DMA later
    while (_IF_TxE(I2C_OLED));
  }
  ssd1306_stop();
}

void ssd1306_drawpixel(uint16_t x, uint16_t y, SSD1306_COLOR_t color) {
  if (x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT) {
    return;
  }
  
  /* Check if pixels are inverted */
  if (SSD1306.Inverted) {
    color = (SSD1306_COLOR_t)!color;
  }
  
  if (color == white) {
    screenRAM[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);
  } else {
    screenRAM[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y % 8));
  }
}

void ssd1306_gotoxy(uint16_t x, uint16_t y) {
  /* Set write pointers */
  SSD1306.CurrentX = x;
  SSD1306.CurrentY = y;
}

char ssd1306_drawchar(char ch, FontDef_t* Font, uint8_t color) {
  uint32_t i, b, j;
  
  b = 0;
  for (i = 0; i < Font->FontHeight; i++) {
	for (j = 0; j < Font->FontWidth; j++) {
      if ((Font->data[(ch-32)*Font->CharBytes + b/8] >> b%8) & 1) {
		ssd1306_drawpixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (uint8_t) color);
      } else {
        ssd1306_drawpixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (uint8_t)!color);
      }
      b++;
    }
  }
  SSD1306.CurrentX += Font->FontWidth;
  return ch;
}

char ssd1306_drawstring(char* str, FontDef_t* Font, SSD1306_COLOR_t color) {
  while (*str) {
    if (ssd1306_drawchar(*str, Font, color) != *str) {
      return *str;
    }
    str++;
  }
  return *str;
}
